
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Model1D &#8212; GeoBIPy 1.0.0 documentation</title>
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Pointcloud classes" href="../pointcloud/pointcloud.html" />
    <link rel="prev" title="Model" href="Model_.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../pointcloud/pointcloud.html" title="Pointcloud classes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Model_.html" title="Model"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">GeoBIPy 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../api.html" >API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../classes.html" >Classes used in GeoBIPy</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="model.html" accesskey="U">Model classes</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-geobipy.src.classes.model.Model1D">
<span id="model1d"></span><h1>Model1D<a class="headerlink" href="#module-geobipy.src.classes.model.Model1D" title="Permalink to this headline">¶</a></h1>
<p>&#64;Model1D_Class
Module describing a 1 Dimensional layered Model</p>
<dl class="class">
<dt id="geobipy.src.classes.model.Model1D.Model1D">
<em class="property">class </em><code class="descclassname">geobipy.src.classes.model.Model1D.</code><code class="descname">Model1D</code><span class="sig-paren">(</span><em>nCells=None</em>, <em>top=None</em>, <em>parameters=None</em>, <em>depth=None</em>, <em>thickness=None</em>, <em>hasHalfspace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Class extension to geobipy.Model</p>
<p>Class creates a representation of the 1D layered earth.
The class contains parameters that describe the physical property of each layer, as well as the layer
thicknesses and interface depths. The model maintains a half space as the lowest layer with infinite extent.
This class allows a probability wheel to be assigned such that the 1D layered earth can be peturbed. i.e.
randomly create, delete, or perturb the layers in the model.  This is a key step in a Markov Chain for Bayesian inference.</p>
<p>Model1D(nCells, top, parameters, depth, thickness)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nCells</strong> (<em>int</em>) – Number of layers in the 1D layered earth. A single layer represents a half space.</li>
<li><strong>top</strong> (<em>numpy.float64</em><em>, </em><em>optional</em>) – Depth to the top of the model</li>
<li><strong>parameters</strong> (<em>geobipy.StatArray</em><em>, </em><em>optional</em>) – Describes the variable within each layer of the model.</li>
<li><strong>depth</strong> (<em>geobipy.StatArray</em><em>, </em><em>optional</em>) – Depths to the lower interface of each layer above the halfspace. Do not provide if thickness is given.</li>
<li><strong>thickness</strong> (<em>geobipy.StatArray</em><em>, </em><em>optional</em>) – Thickness of each layer above the halfspace. Do not provide if depths are given.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – 1D layered earth model.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="#geobipy.src.classes.model.Model1D.Model1D" title="geobipy.src.classes.model.Model1D.Model1D">Model1D</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If nCells is &lt;= 0</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If size(parameters) != nCells</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If size(depth) != nCells - 1</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If size(thickness) != nCells - 1</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code> – If both depth and thickness are provided</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.addToHitMap">
<code class="descname">addToHitMap</code><span class="sig-paren">(</span><em>Hitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.addToHitMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Imposes a model’s parameters with depth onto a 2D Hitmap.</p>
<p>The cells that the parameter-depth profile passes through are accumulated by 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Hitmap</strong> (<em>geobipy.Hitmap</em>) – The hitmap to add to</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.asHistogram2D">
<code class="descname">asHistogram2D</code><span class="sig-paren">(</span><em>variance</em>, <em>Hist</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.asHistogram2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Hitmap from the model given the variance of each layer.</p>
<p>For each depth, creates a normal distribution with a mean equal to the interpolated parameter
at that depth and variance specified with variance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variance</strong> (<em>array_like</em>) – The variance of each layer</li>
<li><strong>Hitmap</strong> (<em>geobipy.Hitmap</em>) – Hitmap to convert the model to.
Must be instantiated before calling so that the model can be interpolated correctly</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.createHdf">
<code class="descname">createHdf</code><span class="sig-paren">(</span><em>parent</em>, <em>myName</em>, <em>nRepeats=None</em>, <em>fillvalue=None</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.createHdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the Metadata for a Model1D in a HDF file</p>
<p>Creates a new group in a HDF file under h5obj.
A nested heirarchy will be created.
This method can be used in an MPI parallel environment, if so however,
a) the hdf file must have been opened with the mpio driver, and
b) createHdf must be called collectively,
i.e., called by every core in the MPI communicator that was used to open the file.
In order to create large amounts of empty space before writing to it in parallel,
the nRepeats parameter will extend the memory in the first dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h5obj</strong> (<em>h5py._hl.files.File</em><em> or </em><em>h5py._hl.group.Group</em>) – A HDF file or group object to create the contents in.</li>
<li><strong>myName</strong> (<em>str</em>) – The name of the group to create.</li>
<li><strong>nRepeats</strong> (<em>int</em><em>, </em><em>optional</em>) – Inserts a first dimension into the first dimension of each attribute of the Model1D of length nRepeats.
This can be used to extend the available memory of the Model1D so that multiple MPI ranks can write to
their respective parts in the extended memory.</li>
<li><strong>fillvalue</strong> (<em>number</em><em>, </em><em>optional</em>) – Initializes the memory in file with the fill value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method can be used in serial and MPI. As an example in MPI.
Given 10 MPI ranks, each with a 10 length array, it is faster to create a 10x10 empty array,
and have each rank write its row. Rather than creating 10 separate length 10 arrays because
the overhead when creating the file metadata can become very cumbersome if done too many times.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">geobipy</span> <span class="k">import</span> <span class="n">Model1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mpi4py</span> <span class="k">import</span> <span class="n">MPI</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a holder for models in memory with more layers than you will expect.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span> <span class="o">=</span> <span class="n">Model1D</span><span class="p">(</span><span class="n">nCells</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This is a collective open of data in the file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fName</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;mpio&#39;</span><span class="p">,</span><span class="n">comm</span><span class="o">=</span><span class="n">world</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Collective creation of space(padded by number of mpi ranks)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span><span class="o">.</span><span class="n">createHdf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;models&#39;</span><span class="p">,</span> <span class="n">nRepeats</span><span class="o">=</span><span class="n">world</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># In a non collective region, we can write to different sections of x in the file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fake a non collective region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">noncollectivewrite</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">world</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># Each rank carries out this code, but it&#39;s not collective.</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">model</span><span class="o">.</span><span class="n">writeHdf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;models&#39;</span><span class="p">,</span>  <span class="n">index</span><span class="o">=</span><span class="n">world</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noncollectivewrite</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">world</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a deepcopy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Deepcopy of Model1D</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">geobipy.Model1D</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.deleteLayer">
<code class="descname">deleteLayer</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.deleteLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a layer from the model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> (<em>int</em>) – The layer to remove.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Model with layer removed.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">geobipy.Model1D</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.depthFromThickness">
<code class="descname">depthFromThickness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.depthFromThickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the thicknesses of each layer, create the depths to each interface. The last depth is inf for the halfspace.</p>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.evaluateHitmapPrior">
<code class="descname">evaluateHitmapPrior</code><span class="sig-paren">(</span><em>Hitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.evaluateHitmapPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the model parameters against a hitmap.</p>
<p>Given a Hitmap describing the probability of the parameters with depth, evaluate the current model using the grid cells it passes through.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Hitmap</strong> (<em>geobipy.Hitmap</em>) – A 2D hitmap with y axis depth, and x axis parameter to evaluate the probability of the model given the hitmap</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – The probability of the model given the hitmap.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.float64</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.fromHdf">
<code class="descname">fromHdf</code><span class="sig-paren">(</span><em>grp</em>, <em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.fromHdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the class from a HDF group</p>
<p>Given the HDF group object, read the contents into an Model1D class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h5obj</strong> (<em>h5py._hl.group.Group</em>) – A HDF group object to write the contents to.</li>
<li><strong>index</strong> (<em>slice</em><em>, </em><em>optional</em>) – If the group was created using the nRepeats option, index specifies the index’th entry from which to read the data.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.getParMeshXIndex">
<code class="descname">getParMeshXIndex</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.getParMeshXIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate the model parameters to a 2D rectilinear mesh.</p>
<p>Uses piece wise constant interpolation of the parameter-depth profile to the y axis of the mesh.
Then the indices into the mesh x axis for those interpolated values are returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mesh</strong> (<em>geobipy.RectilinearMesh2D</em>) – A mesh to interpolate to.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – The indices into mesh.x after interpolating the model parameters to the mesh.y axis.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.hdfName">
<code class="descname">hdfName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.hdfName" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a string that describes class instantiation</p>
<p>Returns a string that should be used as an attr[‘repr’] in a HDF group.
This allows reading of the attribute from the hdf file, evaluating it to return an object,
and then reading the hdf contents via the object’s methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">str</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.insertLayer">
<code class="descname">insertLayer</code><span class="sig-paren">(</span><em>z</em>, <em>par=None</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.insertLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a new layer into a model at a given depth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>numpy.float64</em>) – Depth at which to insert a new interface</li>
<li><strong>par</strong> (<em>numpy.float64</em><em>, </em><em>optional</em>) – Value of the parameter for the new layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – Model with inserted layer.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">geobipy.Model1D</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.interpPar2Mesh">
<code class="descname">interpPar2Mesh</code><span class="sig-paren">(</span><em>par</em>, <em>mesh</em>, <em>matchTop=False</em>, <em>bound=False</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.interpPar2Mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate the model parameters to a 2D rectilinear mesh.</p>
<p>Uses piece wise constant interpolation of the parameter-depth profile to the y axis of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>par</strong> (<em>geobipy.StatArray</em>) – The values to interpolate to the mesh y axis. Must have length Model1D.nCells.</li>
<li><strong>mesh</strong> (<em>geobipy.RectilinearMesh2D</em>) – A mesh to interpolate to.</li>
<li><strong>matchTop</strong> (<em>bool</em><em>, </em><em>optional</em>) – Force the mesh y axis and top of the model to match.</li>
<li><strong>bound</strong> (<em>bool</em><em>, </em><em>optional</em>) – Interpolated values above the top of the model are nan.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The interpolated model parameters at each y axis value of the mesh.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.isInsideConfidence">
<code class="descname">isInsideConfidence</code><span class="sig-paren">(</span><em>Hitmap</em>, <em>percent=95.0</em>, <em>log=None</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.isInsideConfidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the model is insde the specified confidence region of a 2D hitmap</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Hitmap</strong> (<em>geobipy.Hitmap2D</em>) – The hitmap to check against.</li>
<li><strong>percent</strong> (<em>np.float</em><em>, </em><em>optional</em>) – The confidence interval percentage.</li>
<li><strong>log</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to take the parameters to a log base (log).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – All parameter values are within the confidence intervals.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.makePerturbable">
<code class="descname">makePerturbable</code><span class="sig-paren">(</span><em>pWheel</em>, <em>minDepth</em>, <em>maxDepth</em>, <em>maxLayers</em>, <em>prng=None</em>, <em>minThickness=None</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.makePerturbable" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup a model such that it can be randomly perturbed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pWheel</strong> (<em>array_like</em>) – Probability of birth, death, perturb, and no change for the model
e.g. pWheel = [0.5, 0.25, 0.15, 0.1]</li>
<li><strong>minDepth</strong> (<em>float64</em>) – Minimum depth possible for the model</li>
<li><strong>maxDepth</strong> (<em>float64</em>) – Maximum depth possible for the model</li>
<li><strong>maxLayers</strong> (<em>int</em>) – Maximum number of layers allowable in the model</li>
<li><strong>prng</strong> (<em>numpy.random.RandomState</em><em>(</em><em>)</em><em>, </em><em>optional</em>) – Random number generator, if none is given, will use numpy’s global generator.</li>
<li><strong>minThickness</strong> (<em>float64</em><em>, </em><em>optional</em>) – Minimum thickness of any layer. If minThickness = None, minThickness is computed from minDepth, maxDepth, and maxLayers (recommended).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">geobipy.Model1D.perturb()</span></code></dt>
<dd>For a description of the perturbation cycle.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.pad">
<code class="descname">pad</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the properties of a model including all priors or proposals, but pads memory to the given size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> (<em>int</em>) – Create memory upto this size.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Padded model</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">geobipy.Model1D</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.pcolor">
<code class="descname">pcolor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.pcolor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a pseudocolour plot of the 1D Model.</p>
<p>Can take any other matplotlib arguments and keyword arguments e.g. cmap etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><ul class="first simple">
<li><strong>alpha</strong> (<em>scalar or array_like, optional</em>) – If alpha is scalar, behaves like standard matplotlib alpha and opacity is applied to entire plot
If array_like, each pixel is given an individual alpha value.</li>
<li><strong>log</strong> (<em>‘e’ or float, optional</em>) – Take the log of the colour to a base. ‘e’ if log = ‘e’, and a number e.g. log = 10.
Values in c that are &lt;= 0 are masked.</li>
<li><strong>equalize</strong> (<em>bool, optional</em>) – Equalize the histogram of the colourmap so that all colours have an equal amount.</li>
<li><strong>nbins</strong> (<em>int, optional</em>) – Number of bins to use for histogram equalization.</li>
<li><strong>xscale</strong> (<em>str, optional</em>) – Scale the x axis? e.g. xscale = ‘linear’ or ‘log’</li>
<li><strong>yscale</strong> (<em>str, optional</em>) – Scale the y axis? e.g. yscale = ‘linear’ or ‘log’.</li>
<li><strong>flipX</strong> (<em>bool, optional</em>) – Flip the X axis</li>
<li><strong>flipY</strong> (<em>bool, optional</em>) – Flip the Y axis</li>
<li><strong>grid</strong> (<em>bool, optional</em>) – Plot the grid</li>
<li><strong>noColorbar</strong> (<em>bool, optional</em>) – Turn off the colour bar, useful if multiple customPlots plotting routines are used on the same figure.</li>
<li><strong>trim</strong> (<em>bool, optional</em>) – Set the x and y limits to the first and last non zero values along each axis.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">matplotlib.Axes</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ax</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">matplotlib.pyplot.pcolormesh()</span></code></dt>
<dd>For additional keyword arguments you may use.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.perturb">
<code class="descname">perturb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.perturb" title="Permalink to this definition">¶</a></dt>
<dd><p>Perturb a model</p>
<p>Generates a new model by perturbing the current model based on four probabilities.
The probabilities correspond to
* Birth, the insertion of a new layer into the model
* Death, the deletion of a layer from the model
* Change, change one the existing interfaces
* No change, do nothing and return the original</p>
<p>The method self.makePerturbable must be used before calling self.perturb.</p>
<p>The perturbation starts by generating a random number from a uniform distribution to determine which cycle to go through.
If a layer is created, or an interface perturbed, any resulting layer thicknesses must be greater than the minimum thickness <span class="math notranslate nohighlight">\(h_{min}\)</span>.
If the new layer thickness test fails, the birth or perturbation tries again. If the cycle fails after 10 tries, the entire process begins again
such that a death, or no change is possible thus preventing any neverending cycles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>out[0]</strong> (<em>Model1D</em>) – The perturbed model</li>
<li><strong>out[1]</strong> (<em>int</em>) – Integer for the type of perturbation, [0,1,2,3] = [birth, death, change, no change]</li>
<li><strong>out[2]</strong> (<em>list</em>) – Two values for the cycle that was chosen. Only matters if the cycle was a birth, death, or change.
For a birth, contains the depth of the new layer and None [newZ, None]
For a death, contains the index of the layer that was deleted [iDeleted, None]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">geobipy.Model1D.makePerturbable()</span></code></dt>
<dd>Must be used before calling self.perturb</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a 1D model parameters as a line against depth</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reciprocateX</strong> (<em>bool</em><em>, </em><em>optional</em>) – Take the reciprocal of the x axis</li>
<li><strong>xscale</strong> (<em>str</em><em>, </em><em>optional</em>) – Scale the x axis? e.g. xscale = ‘linear’ or ‘log’</li>
<li><strong>yscale</strong> (<em>str</em><em>, </em><em>optional</em>) – Scale the y axis? e.g. yscale = ‘linear’ or ‘log’</li>
<li><strong>flipX</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flip the X axis</li>
<li><strong>flipY</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flip the Y axis</li>
<li><strong>noLabels</strong> (<em>bool</em><em>, </em><em>optional</em>) – Do not plot the labels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.priorProbability">
<code class="descname">priorProbability</code><span class="sig-paren">(</span><em>sPar</em>, <em>sGradient</em>, <em>limits=None</em>, <em>components=False</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.priorProbability" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior probability for the 1D Model.</p>
<p>The following equation describes the components of the prior that correspond to the Model1D,</p>
<div class="math notranslate nohighlight">
\[p(k | I)p(\boldsymbol{z}| k, I)p(\boldsymbol{\sigma} | k, \boldsymbol{z}, I),\]</div>
<p>where <span class="math notranslate nohighlight">\(k, I, \boldsymbol{z}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\sigma}\)</span> are the number of layers, prior information, interface depth, and physical property, respectively.</p>
<p>The multiplication here can be turned into a summation by taking the log of the components.</p>
<p><strong>Prior on the number of layers</strong></p>
<p>Uninformative prior using a uniform distribution.</p>
<div class="math notranslate nohighlight" id="equation-layers">
<span class="eqno">(1)<a class="headerlink" href="#equation-layers" title="Permalink to this equation">¶</a></span>\[p(k | I) =
\begin{cases}
\frac{1}{k_{max} - 1} &amp; \quad 1 \leq k \leq k_{max} \newline
0 &amp; \quad otherwise
\end{cases}.\]</div>
<p><strong>Prior on the layer interface depths</strong></p>
<p>We use order statistics for the prior on layer depth interfaces.</p>
<div class="math notranslate nohighlight" id="equation-depth">
<span class="eqno">(2)<a class="headerlink" href="#equation-depth" title="Permalink to this equation">¶</a></span>\[p(\boldsymbol{z} | k, I) = \frac{(k -1)!}{\prod_{i=0}^{k-1} \Delta z_{i}},\]</div>
<p>where the numerator describes the number of ways that <span class="math notranslate nohighlight">\((k - 1)\)</span> interfaces can be ordered and
<span class="math notranslate nohighlight">\(\Delta z_{i} = (z_{max} - z_{min}) - 2 i h_{min}\)</span> describes the depth interval that is available to place a layer when there are already i interfaces in the model</p>
<p><strong>Prior on the physical parameter</strong></p>
<p>If we use a multivariate normal distribution to describe the joint prior pdf for log-parameter values in all layers we use,</p>
<div class="math notranslate nohighlight" id="equation-parameter">
<span class="eqno">(3)<a class="headerlink" href="#equation-parameter" title="Permalink to this equation">¶</a></span>\[p(\boldsymbol{\sigma} | k, I) = \left[(2\pi)^{k} |\boldsymbol{C}_{\boldsymbol{\sigma}0}|\right]^{-\frac{1}{2}} e ^{-\frac{1}{2}(\boldsymbol{\sigma} - \boldsymbol{\sigma}_{0})^{T} \boldsymbol{C}_{\boldsymbol{\sigma} 0}^{-1} (\boldsymbol{\sigma} - \boldsymbol{\sigma}_{0})}\]</div>
<p><strong>Prior on the gradient of the physical parameter with depth</strong></p>
<p>If instead we wish to apply a multivariate normal distribution to the gradient of the parameter with depth we get</p>
<div class="math notranslate nohighlight" id="equation-gradient">
<span class="eqno">(4)<a class="headerlink" href="#equation-gradient" title="Permalink to this equation">¶</a></span>\[p(\boldsymbol{\sigma} | k, I) = \left[(2\pi)^{k-1} |\boldsymbol{C}_{\nabla_{z}}|\right]^{-\frac{1}{2}} e ^{-\frac{1}{2}(\nabla_{z} \boldsymbol{\sigma})^{T} \boldsymbol{C}_{\nabla_{z}}^{-1} (\nabla_{z}\boldsymbol{\sigma})}\]</div>
<p>where the parameter gradient <span class="math notranslate nohighlight">\(\nabla_{z}\sigma\)</span> at the ith layer is computed via</p>
<div class="math notranslate nohighlight" id="equation-dpdz">
<span class="eqno">(5)<a class="headerlink" href="#equation-dpdz" title="Permalink to this equation">¶</a></span>\[\nabla_{z}^{i}\sigma = \frac{\sigma_{i+1} - \sigma_{i}}{h_{i} - h_{min}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma_{i+1}\)</span> and <span class="math notranslate nohighlight">\(\sigma_{i}\)</span> are the log-parameters on either side of an interface, <span class="math notranslate nohighlight">\(h_{i}\)</span> is the log-thickness of the ith layer, and <span class="math notranslate nohighlight">\(h_{min}\)</span> is the minimum log thickness defined by</p>
<div class="math notranslate nohighlight" id="equation-minthickness">
<span class="eqno">(6)<a class="headerlink" href="#equation-minthickness" title="Permalink to this equation">¶</a></span>\[h_{min} = \frac{z_{max} - z_{min}}{2 k_{max}}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_{max}\)</span> is a maximum number of layers, set to be far greater than the expected final solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sPar</strong> (<em>bool</em>) – Evaluate the prior on the parameters <a class="reference internal" href="#equation-parameter">(3)</a> in the final probability</li>
<li><strong>sGradient</strong> (<em>bool</em>) – Evaluate the prior on the parameter gradient <a class="reference internal" href="#equation-gradient">(4)</a> in the final probability</li>
<li><strong>limits</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Bound the parameter value.  If the parameter value falls outside of the limits, -inf is returned.</li>
<li><strong>components</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return all components used in the final probability as well as the final probability</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>probability</strong> (<em>numpy.float64</em>) – The probability</li>
<li><strong>components</strong> (<em>array_like, optional</em>) – Return the components of the probability, i.e. the individually evaluated priors as a second return argument if comonents=True on input.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.smoothModelPrior">
<code class="descname">smoothModelPrior</code><span class="sig-paren">(</span><em>hmin=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.smoothModelPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior for the gradient of the parameter with depth</p>
<p><strong>Prior on the gradient of the physical parameter with depth</strong></p>
<p>If instead we wish to apply a multivariate normal distribution to the gradient of the parameter with depth we get</p>
<div class="math notranslate nohighlight">
\[p(\boldsymbol{\sigma} | k, I) = \left[(2\pi)^{k-1} |\boldsymbol{C}_{\nabla_{z}}|\right]^{-\frac{1}{2}} e ^{-\frac{1}{2}(\nabla_{z} \boldsymbol{\sigma})^{T} \boldsymbol{C}_{\nabla_{z}}^{-1} (\nabla_{z}\boldsymbol{\sigma})}\]</div>
<p>where the parameter gradient <span class="math notranslate nohighlight">\(\nabla_{z}\sigma\)</span> at the ith layer is computed via</p>
<div class="math notranslate nohighlight">
\[\nabla_{z}^{i}\sigma = \frac{\sigma_{i+1} - \sigma_{i}}{h_{i} - h_{min}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma_{i+1}\)</span> and <span class="math notranslate nohighlight">\(\sigma_{i}\)</span> are the log-parameters on either side of an interface, <span class="math notranslate nohighlight">\(h_{i}\)</span> is the log-thickness of the ith layer, and <span class="math notranslate nohighlight">\(h_{min}\)</span> is the minimum log thickness defined by</p>
<div class="math notranslate nohighlight">
\[h_{min} = \frac{z_{max} - z_{min}}{2 k_{max}}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_{max}\)</span> is a maximum number of layers, set to be far greater than the expected final solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hmin</strong> (<em>float64</em>) – The minimum thickness of any layer.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – The probability given the prior on the gradient of the parameters with depth.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.float64</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.summary">
<code class="descname">summary</code><span class="sig-paren">(</span><em>out=False</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a summary of the 1D model</p>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.thicknessFromDepth">
<code class="descname">thicknessFromDepth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.thicknessFromDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the depths to each interface, compute the layer thicknesses. The last thickness is nan for the halfspace.</p>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.toHdf">
<code class="descname">toHdf</code><span class="sig-paren">(</span><em>hObj</em>, <em>myName</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.toHdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the Model1D to an HDF object</p>
<p>Creates and writes a new group in a HDF file under h5obj.
A nested heirarchy will be created.
This function modifies the file metadata and writes the contents at the same time and
should not be used in a parallel environment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h5obj</strong> (<em>h5py._hl.files.File</em><em> or </em><em>h5py._hl.group.Group</em>) – A HDF file or group object to write the contents to.</li>
<li><strong>myName</strong> (<em>str</em>) – The name of the group to write to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">geobipy</span> <span class="k">import</span> <span class="n">Model1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">par</span> <span class="o">=</span> <span class="n">StatArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="s2">&quot;Test&quot;</span><span class="p">,</span> <span class="s2">&quot;units&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thk</span> <span class="o">=</span> <span class="n">StatArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span> <span class="o">=</span> <span class="n">Model1D</span><span class="p">(</span><span class="n">nCells</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">par</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thk</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="geobipy.src.classes.model.Model1D.Model1D.writeHdf">
<code class="descname">writeHdf</code><span class="sig-paren">(</span><em>h5obj</em>, <em>myName</em>, <em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#geobipy.src.classes.model.Model1D.Model1D.writeHdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the Metadata for a Model1D in a HDF file</p>
<p>Creates a new group in a HDF file under h5obj.
A nested heirarchy will be created.
This method can be used in an MPI parallel environment, if so however, a) the hdf file must have been opened with the mpio driver,
and b) createHdf must be called collectively, i.e., called by every core in the MPI communicator that was used to open the file.
In order to create large amounts of empty space before writing to it in parallel, the nRepeats parameter will extend the memory
in the first dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h5obj</strong> (<em>h5py._hl.files.File</em><em> or </em><em>h5py._hl.group.Group</em>) – A HDF file or group object to create the contents in.</li>
<li><strong>myName</strong> (<em>str</em>) – The name of the group to create.</li>
<li><strong>fillvalue</strong> (<em>number</em><em>, </em><em>optional</em>) – Initializes the memory in file with the fill value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method can be used in serial and MPI. As an example in MPI.
Given 10 MPI ranks, each with a 10 length array, it is faster to create a 10x10 empty array, and have each rank write its row.
Rather than creating 10 separate length 10 arrays because the overhead when creating the file metadata can become very
cumbersome if done too many times.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">geobipy</span> <span class="k">import</span> <span class="n">Model1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mpi4py</span> <span class="k">import</span> <span class="n">MPI</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a holder for models in memory with more layers than you will expect.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span> <span class="o">=</span> <span class="n">Model1D</span><span class="p">(</span><span class="n">nCells</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This is a collective open of data in the file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fName</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;mpio&#39;</span><span class="p">,</span><span class="n">comm</span><span class="o">=</span><span class="n">world</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Collective creation of space(padded by number of mpi ranks)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span><span class="o">.</span><span class="n">createHdf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;models&#39;</span><span class="p">,</span> <span class="n">nRepeats</span><span class="o">=</span><span class="n">world</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># In a non collective region, we can write to different sections of x in the file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fake a non collective region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">noncollectivewrite</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">world</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># Each rank carries out this code, but it&#39;s not collective.</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">model</span><span class="o">.</span><span class="n">writeHdf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;models&#39;</span><span class="p">,</span>  <span class="n">index</span><span class="o">=</span><span class="n">world</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noncollectivewrite</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">world</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="Model_.html"
                        title="previous chapter">Model</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../pointcloud/pointcloud.html"
                        title="next chapter">Pointcloud classes</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/content/api/classes/model/Model1D.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../pointcloud/pointcloud.html" title="Pointcloud classes"
             >next</a> |</li>
        <li class="right" >
          <a href="Model_.html" title="Model"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">GeoBIPy 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../api.html" >API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../classes.html" >Classes used in GeoBIPy</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="model.html" >Model classes</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright None.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
  </body>
</html>